import{_ as a,c as i,I as n,aU as t,o as e,E as h}from"./chunks/framework.CpXV_ol5.js";const y=JSON.parse('{"title":"详解 Vue 中 watch 的使用方法及注意事项","description":"","frontmatter":{"title":"详解 Vue 中 watch 的使用方法及注意事项"},"headers":[],"relativePath":"zh/blog/vuejs2/Vue侦听器watch的使用方法及注意事项.md","filePath":"zh/blog/vuejs2/Vue侦听器watch的使用方法及注意事项.md","lastUpdated":1727083629000}'),l={name:"zh/blog/vuejs2/Vue侦听器watch的使用方法及注意事项.md"},p=t(`<h1 id="详解-vue-中-watch-的使用方法及注意事项" tabindex="-1">详解 Vue 中 watch 的使用方法及注意事项 <a class="header-anchor" href="#详解-vue-中-watch-的使用方法及注意事项" aria-label="Permalink to &quot;详解 Vue 中 watch 的使用方法及注意事项&quot;">​</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>Vue 的 Watch 是一个非常有用的功能，它能够监听 Vue 实例数据的变化并执行相应的操作。本篇文章将详细介绍 Vue Watch 的使用方法和注意事项，让你能够充分利用 Watch 来解决 Vue 开发中的各种问题。</p><h2 id="_1-watch-是什么" tabindex="-1">1. Watch 是什么？ <a class="header-anchor" href="#_1-watch-是什么" aria-label="Permalink to &quot;1. Watch 是什么？&quot;">​</a></h2><h3 id="_1-1-watch-的作用和优势" tabindex="-1">1.1 Watch 的作用和优势 <a class="header-anchor" href="#_1-1-watch-的作用和优势" aria-label="Permalink to &quot;1.1 Watch 的作用和优势&quot;">​</a></h3><p>Watch 是 Vue 中监视数据变化的一种方法，它允许开发者监听特定数据的变化并执行相应的操作。Watch 的作用和优势如下：</p><ol><li><p><strong>监听数据变化</strong>：Watch 能够监听 Vue 实例中数据的变化，当数据发生改变时自动执行相应的回调函数。</p></li><li><p><strong>异步操作</strong>：与 Computed 不同，Watch 可以执行异步操作。这对于需要发送网络请求或执行复杂的计算的场景非常有用。</p></li><li><p><strong>数据联动</strong>：当一个数据发生变化时，有时需要同时更新其他相关的数据。Watch 提供了一种简洁的方式来实现数据之间的联动。</p></li><li><p><strong>更精确的控制</strong>：相比于 Computed，Watch 能够更精确地控制到底哪些数据需要监听，以及何时以及如何触发相应的操作。</p></li><li><p><strong>应用场景广泛</strong>：Watch 可以应用于各种场景，包括表单验证、异步操作、数据统计和监控等，非常灵活。</p></li></ol><p>Vue 的 Watch 功能为开发者提供了一种方便、灵活、可靠的处理数据变化的方法，能够更好地满足复杂应用的需求，并提升开发效率。</p><h3 id="_1-2-watch-的工作原理" tabindex="-1">1.2 Watch 的工作原理 <a class="header-anchor" href="#_1-2-watch-的工作原理" aria-label="Permalink to &quot;1.2 Watch 的工作原理&quot;">​</a></h3><p>想要更好的理解 Watch，必须要理解 Watch 是如何工作的，它的工作原理有几个重要的关键点如下：</p><ol><li><p><strong>Watch 对象的定义</strong>：在 Vue 组件实例中，我们可以通过在<code>watch</code>选项中定义一个对象来创建 Watch 监听器。这个对象中可以包含多个键值对，其中键是要监听的数据属性的名称，值是处理数据变化的回调函数。</p></li><li><p><strong>Watch 的注册</strong>：当 Vue 组件实例创建时，Watch 对象会被注册并与组件实例关联起来。Vue 会遍历 Watch 对象，并为每个键值对创建一个 Watcher 实例。</p></li><li><p><strong>Watcher 实例的创建</strong>：Watcher 实例是 Watch 的核心，它负责监听和响应数据变化。Watcher 实例在 Watch 对象的键值对中创建，并与要监听的数据属性进行关联。</p></li><li><p><strong>数据的变化检测</strong>：当被 Watch 监听的数据发生变化时，Vue 会触发数据的变化检测机制。这个机制会比较新旧值，如果发现变化，就会通知相关的 Watcher 实例。</p></li><li><p><strong>Watcher 的回调执行</strong>：一旦 Watcher 实例接收到变化通知，它将调用相应的回调函数。这个回调函数可以是用户自定义的，用于实现数据变化后的特定操作。</p></li></ol><p>Vue 的 Watch 工作原理是通过 Watcher 实例来监听数据的变化，一旦数据发生变化，Watcher 就会执行相应的回调函数。这种机制能够让开发者以声明式的方式来处理数据的变化，使代码更加清晰和可读。同时，Vue 的响应式系统能够高效地追踪数据的变化并自动更新视图，从而提升应用性能和开发效率。</p><h3 id="_1-3-watch-和-computed-的区别" tabindex="-1">1.3 Watch 和 Computed 的区别 <a class="header-anchor" href="#_1-3-watch-和-computed-的区别" aria-label="Permalink to &quot;1.3 Watch 和 Computed 的区别&quot;">​</a></h3><p>Vue 中的计算属性（Computed）也是 Vue 实例中非常重要的一个特性，用于对 Vue 实例的数据进行动态计算，且具有缓存机制。想要详细了解的可以参考我之前的文章，本文不作过多的赘述，只总结一下 Watch 和 Computed 的使用区别。</p><p>了解 Computed 请点击：<a href="https://juejin.cn/post/7291936022882402356" target="_blank" rel="noreferrer">深入浅出 Vue 计算属性 ( computed ) 的使用与优化</a></p><p>Watch 和 Computed 是 Vue 中两种用于处理数据变化的方法，它们之间有以下几个区别：</p><ol><li><p><strong>用法不同</strong>：Watch 使用<code>watch</code>选项来定义一个观察者对象，监听某个数据的变化，当数据发生变化时执行相应的回调函数；而 Computed 使用<code>computed</code>选项来定义一个计算属性，根据依赖的数据动态计算得到一个新的值。</p></li><li><p><strong>监听方式不同</strong>：Watch 可以监听任意数据的变化，甚至是嵌套对象的属性；而 Computed 只能依赖已经存在的响应式数据，它会根据数据的变化自动更新计算得到的值。</p></li><li><p><strong>响应方式不同</strong>：Watch 的回调函数是在数据变化后执行的，可以执行异步操作；而 Computed 的计算属性是在依赖的数据变化时自动更新的，对外表现为一个缓存值，只有当依赖的数据发生变化时才会重计算。</p></li><li><p><strong>使用场景不同</strong>：Watch 适用于需要在数据变化时执行异步操作、执行复杂逻辑的场景，例如监听表单输入、发起网络请求等；而 Computed 适用于需要根据已有数据计算得到一个新的值的场景，例如对数据进行过滤、格式化等操作。</p></li><li><p><strong>计算结果的缓存</strong>：Computed 具有缓存功能，当依赖的数据没有发生变化时，直接返回上一次的计算结果，避免重复计算；而 Watch 没有缓存功能，每当被监听的数据发生变化时，都会执行回调函数。</p></li></ol><blockquote><p><strong>总结</strong>：Watch 和 Computed 在处理数据变化时有着不同的应用场景和使用方式。Watch 适用于处理异步操作、执行复杂逻辑等场景，而 Computed 适用于对已有数据进行计算生成新值的场景，且具有缓存功能。开发者在根据实际需求选择时，需要考虑数据的变化频率、计算的复杂程度等因素。</p></blockquote><h2 id="_2-watch-的基本使用方法" tabindex="-1">2. Watch 的基本使用方法 <a class="header-anchor" href="#_2-watch-的基本使用方法" aria-label="Permalink to &quot;2. Watch 的基本使用方法&quot;">​</a></h2><h3 id="_2-1-定义-watch" tabindex="-1">2.1 定义 Watch <a class="header-anchor" href="#_2-1-定义-watch" aria-label="Permalink to &quot;2.1 定义 Watch&quot;">​</a></h3><p>Watch 的基本使用方法步骤如下：</p><ol><li><p>在 Vue 组件的<code>watch</code>选项中定义一个观察者对象，可以是一个简单的对象或者一个计算属性名称的数组。</p></li><li><p>观察者对象的键是要监听的数据属性的名称，值是一个回调函数，用于处理数据变化后的操作。</p></li><li><p>在回调函数中，可以接收两个参数：</p><ul><li>newVal: 变化后的新值</li><li>oldVal: 变化前的旧值</li></ul></li><li><p>在回调函数中实现特定的逻辑，例如发送请求、更新其他数据等。</p></li></ol><p>通过以上步骤，就可以在 Vue 组件中使用 Watch 来监听指定数据的变化，并在变化后执行相应的操作。可以在<code>watch</code>选项中定义多个观察者对象，以监听多个数据属性的变化，可以实现监听单个、多个、对象和数组等数据的变化，并分别指定不同的回调函数来处理不同的数据变化。</p><h3 id="_2-1-监听单个数据" tabindex="-1">2.1 监听单个数据 <a class="header-anchor" href="#_2-1-监听单个数据" aria-label="Permalink to &quot;2.1 监听单个数据&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 监听名为&quot;foo&quot;的数据属性</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newVal, oldVal) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理数据变化后的操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo属性发生变化了，新值为:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, newVal, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;旧值为:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, oldVal);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 可以在这里执行其他操作，例如发送请求、更新其他数据等</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>通过在<code>watch</code>选项中定义一个观察者对象，可以监听单个数据属性的变化。回调函数中可以接收到变化后的新值和变化前的旧值。</p><h3 id="_2-3-监听多个数据" tabindex="-1">2.3 监听多个数据 <a class="header-anchor" href="#_2-3-监听多个数据" aria-label="Permalink to &quot;2.3 监听多个数据&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 监听名为&quot;foo&quot;和&quot;bar&quot;的数据属性</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newVal, oldVal) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理foo属性变化后的操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newVal, oldVal) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 处理bar属性变化后的操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>通过在<code>watch</code>选项中定义多个观察者对象，可以同时监听多个数据属性的变化。每个观察者对象都对应一个属性的名称和回调函数。</p><h3 id="_2-4-监听对象属性" tabindex="-1">2.4 监听对象属性 <a class="header-anchor" href="#_2-4-监听对象属性" aria-label="Permalink to &quot;2.4 监听对象属性&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 监听整个对象的变化</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  obj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newVal, oldVal) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 处理obj属性变化后的操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    deep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 深度监听</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 监听对象属性&quot;obj.foo&quot;的变化</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;obj.foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">oldVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 处理obj.foo属性变化后的操作</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    deep: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 深度监听</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>通过在<code>watch</code>选项中定义观察者对象时，可以使用点语法监听对象属性的变化。可以设置<code>deep</code>选项为<code>true</code>来深度监听对象的变化，即使对象属性的值发生变化，也会触发回调函数。</p><h3 id="_2-5-监听数组元素" tabindex="-1">2.5 监听数组元素 <a class="header-anchor" href="#_2-5-监听数组元素" aria-label="Permalink to &quot;2.5 监听数组元素&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 监听数组元素的变化</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  arr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newVal, oldVal) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 处理arr数组的变化</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    deep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 深度监听</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>通过在<code>watch</code>选项中定义观察者对象时，可以使用数组监听数组元素的变化。同样，可以设置<code>deep</code>选项为<code>true</code>来深度监听数组的变化，即使数组元素的值发生变化，也会触发回调函数。</p><blockquote><p>通过以上的分析，可以根据需要在 Vue 的<code>watch</code>选项中监听单个或多个数据属性的变化，并根据回调函数处理相应的操作。同时，可以使用点语法监听对象属性的变化，以及设置<code>deep</code>选项来深度监听对象和数组的变化。</p></blockquote><h2 id="_3-watch-的高级用法" tabindex="-1">3. Watch 的高级用法 <a class="header-anchor" href="#_3-watch-的高级用法" aria-label="Permalink to &quot;3. Watch 的高级用法&quot;">​</a></h2><h3 id="_3-1-深度监听数据的变化" tabindex="-1">3.1 深度监听数据的变化 <a class="header-anchor" href="#_3-1-深度监听数据的变化" aria-label="Permalink to &quot;3.1 深度监听数据的变化&quot;">​</a></h3><p>在 Vue 中，深度监听数据的变化意味着不仅监听对象或数组本身的变化，还监听它们内部属性或元素的变化。</p><p>当将<code>deep</code>选项设置为<code>true</code>时，Vue 会递归遍历对象的所有属性或数组的所有元素，并为每个属性或元素都创建一个深度观察者。这样，无论是对象的某个属性还是数组的某个元素发生变化，都能触发相应的回调函数。</p><p>使用深度监听来监听对象属性的变化如下所示：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;obj.foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">oldVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;obj.foo属性发生变化了，新值为:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, newVal, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;旧值为:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, oldVal);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    deep: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 深度监听</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在上述示例中，<code>obj</code>是一个对象，<code>foo</code>是它的一个属性。当<code>obj</code>或<code>foo</code>发生变化时，都能触发深度观察者的回调函数。</p><p>因此，通过在 Vue 的<code>watch</code>选项中将<code>deep</code>选项设置为<code>true</code>，可以实现对对象属性或数组元素的深度监听，从而捕捉到它们内部值的变化。</p><blockquote><p><strong>注意</strong>：深度监听会带来一些<strong>性能开销</strong>，因为它需要递归遍历对象或数组的所有属性或元素。因此，只在需要深度监听的情况下使用，以避免不必要的开销。</p><p>还需要特别注意的是，深度监听仅适用于<strong>对象和数组</strong>，对于基本类型的数据如字符串、数字等是不起作用的。</p></blockquote><h3 id="_3-2-立即执行-watch-回调函数" tabindex="-1">3.2 立即执行 Watch 回调函数 <a class="header-anchor" href="#_3-2-立即执行-watch-回调函数" aria-label="Permalink to &quot;3.2 立即执行 Watch 回调函数&quot;">​</a></h3><p>在 Vue 中，watch 选项的回调函数默认是在被监听的数据发生变化后异步执行的，即在下一次事件循环中执行。</p><p>然而，有时我们可能需要立即响应数据变化，并在变化发生后立即执行回调函数。为了实现这一需求，Vue 提供了<code>immediate</code>选项。</p><p>当在 watch 选项中设置<code>immediate: true</code>时，Vue 会在监听开始之初立即执行回调函数，无论数据是否已经发生变化。</p><p>使用<code>immediate</code>选项来实现立即执行 watch 回调函数的效果如下所示：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newVal, oldVal) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo属性发生变化了，新值为:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, newVal, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;旧值为:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, oldVal);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    immediate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 立即执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在上述示例中，当 Vue 实例创建时，会立即执行一次<code>foo</code>属性的 watch 回调函数，无论<code>foo</code>的值是否已经发生变化。随后，如果<code>foo</code>发生变化，Vue 会在下一次事件循环中再次执行 watch 回调函数。</p><p>总之，通过在 Vue 的 watch 选项中设置<code>immediate: true</code>，可以立即执行 watch 回调函数，不等待数据的真正变化。这在某些情况下可以用于立即响应数据变化并执行相关操作的需求。</p><blockquote><p><strong>注意</strong>：当设置<code>immediate: true</code>时，回调函数会在监听开始时立即执行一次，并且不会等待侦听的数据属性的真正变化。这意味着你可能无法获得先前的值，因为此时回调函数仍然是在数据变化之前执行的。</p></blockquote><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>在本篇文章中，我们详细介绍了 Vue 中 watch 选项的基本使用方法。通过 watch 选项，我们可以监听数据的变化，并在变化发生时执行相应的操作。</p><p>其次，我们有重点的学习到了 Watch 的几个高级用法，了解了如何使用深度监听 <code>deep</code> 来递归监听对象内部属性的变化，以及如何使用 <code>immediate</code> 选项在初始加载时立即执行回调函数。</p><p>相信通过本文的学习，你已经了解了 Vue 中 watch 选项的详细使用方法，可以在开发 Vue 应用时更加灵活和高效地处理数据的变化了。</p>`,58);function k(o,c,d,r,E,g){const s=h("ArticleFooter");return e(),i("div",null,[p,n(s,{link:"https://juejin.cn/post/7293151700867956755"})])}const F=a(l,[["render",k]]);export{y as __pageData,F as default};
