import{_ as i,c as a,I as n,aU as p,o as l,E as t}from"./chunks/framework.CpXV_ol5.js";const F=JSON.parse('{"title":"JS设计模式之桥接模式：搭建跨越维度的通路","description":"","frontmatter":{"title":"JS设计模式之桥接模式：搭建跨越维度的通路"},"headers":[],"relativePath":"zh/blog/design-pattern/结构型-桥接模式.md","filePath":"zh/blog/design-pattern/结构型-桥接模式.md","lastUpdated":1727083629000}'),h={name:"zh/blog/design-pattern/结构型-桥接模式.md"},e=p(`<h1 id="结构型-桥接模式" tabindex="-1">结构型 - 桥接模式 <a class="header-anchor" href="#结构型-桥接模式" aria-label="Permalink to &quot;结构型 - 桥接模式&quot;">​</a></h1><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f81cd6d72f2944fc84dfe9b8250de0c7~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=664&amp;h=328&amp;s=122934&amp;e=png&amp;b=128383" alt="image.png"></p><h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p>在软件开发中，我们经常遇到需要对不同的抽象类进行不同的实现的情况，而传统的对象嵌套并不是一个优雅且可扩展的解决方案，因此这正是桥接模式的用武之地。桥接模式通过将抽象与实现分离，使得它们可以独立变化，从而提供了更好的可扩展性和代码重用性。</p><p>在本篇文章中，我们将从桥接模式的基本概念出发，深入剖析其原理和实现方法。我们将学习如何创建抽象类和实现类，并通过桥接类将它们连接起来。同时，我们还将通过实际案例来展示桥接模式的应用，以及它与其他设计模式的关系。</p><h2 id="一-桥接模式的基本概念" tabindex="-1">一. 桥接模式的基本概念 <a class="header-anchor" href="#一-桥接模式的基本概念" aria-label="Permalink to &quot;一. 桥接模式的基本概念&quot;">​</a></h2><h3 id="_1-什么是桥接模式" tabindex="-1">1. 什么是桥接模式 <a class="header-anchor" href="#_1-什么是桥接模式" aria-label="Permalink to &quot;1. 什么是桥接模式&quot;">​</a></h3><p>桥接模式（<code>Bridge Pattern</code>）是一种重要的结构型设计模式，它主要用于解耦抽象和实现之间的关系，使它们能够独立变化。在 JavaScript 中，桥接模式允许我们将抽象和具体实现部分分离，使它们可以独立进行扩展和演化。</p><p>在传统的 JavaScript 开发中，我们通常使用继承来实现抽象和具体实现之间的关系。例如，我们可以定义一个基类，然后通过创建子类来实现不同的具体实现。这种方式存在一些问题，例如子类的扩展会导致类的爆炸性增长，并且难以应对多个维度的变化。</p><p>而桥接模式则提供了一种更加灵活和可扩展的解决方案。它通过使用抽象接口和具体实现类之间的桥接，将它们解耦并以独立的方式进行演化。通过桥接模式，我们可以在运行时动态地将抽象和实现连接起来，而无需在编译时进行固定的绑定。</p><p>在桥接模式中，抽象类是一个具有抽象方法的类或接口，它定义了抽象部分的接口。具体实现类是实现抽象类的具体类，它实现了抽象部分的具体操作。桥接类充当桥梁，将抽象类和具体实现类连接起来，通过调用具体实现类的方法来实现抽象部分的功能。</p><h3 id="_2-桥接模式的核心要素" tabindex="-1">2. 桥接模式的核心要素 <a class="header-anchor" href="#_2-桥接模式的核心要素" aria-label="Permalink to &quot;2. 桥接模式的核心要素&quot;">​</a></h3><p>JavaScript 桥接模式的核心要素包括以下三部分：</p><ol><li><p><strong>抽象类（或接口）</strong>：抽象类定义了抽象部分的接口和行为，它是桥接模式中的核心概念。抽象类为实现提供了一个承的基础，它声明了抽象方法和属性，描述了抽象部分的功能。在 JavaScript 中，抽象类可以通过类（class）或者接口（interface）来定义。</p></li><li><p><strong>实现类</strong>：实现类提供了抽象部分的具体实现。它是抽象类的具体子类，在实现类中实现了抽象类中声明的抽象方法和属性。实现类可以根据需求进行扩展和修改，不会影响到抽象类的设计。在 JavaScript 中，实现类可以是普通的 JavaScript 类。</p></li><li><p><strong>桥接类</strong>：桥接类充当了抽象类和实现类之间的桥梁，将抽象部分的行为委托给具体实现。桥接类包含一个对实现类的引用，将抽象部分的方法调用委托给实现类。通过桥接类，抽象类和实现类可以独立地变化，它们之间解耦合，使得系统更加灵活和可扩展。</p></li></ol><p>总结：JavaScript 桥接模式的核心要素包括抽象类（或接口）、实现类和桥接类。抽象类定义抽象部分的接口和行为，实现类提供抽象部分的具体实现，桥接类充当抽象类和实现类之间的桥梁，将抽象部分的行为委托给具体实现。这样可以实现抽象和实现的解耦，提供更好的可扩展性和灵活性。</p><h3 id="_3-uml-类图说明" tabindex="-1">3. UML 类图说明 <a class="header-anchor" href="#_3-uml-类图说明" aria-label="Permalink to &quot;3. UML 类图说明&quot;">​</a></h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be686966c6b34740943b1930fdfa594a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1292&amp;h=580&amp;s=33478&amp;e=png&amp;b=ffffff" alt="image.png"></p><ul><li><p><strong>抽象部分</strong>（<code>Abstraction</code>）：是一个抽象类或接口，它定义了抽象部分的方法。在 JavaScript 中，我们使用构造函数或类来代表抽象部分。</p></li><li><p><strong>扩充抽象部分</strong>（<code>RefAbstraction</code>）：是抽象部分具体实现类。在 JavaScript 中，我们使用子类来代表扩充抽象部分，它继承了抽象部分并可以扩展额外的功能。</p></li><li><p><strong>实现部分</strong>（<code>Implementor</code>）：是一个接口或抽象类，它定义了实现部分的方法。在 JavaScript 中，我们使用对象字面量或构造函数来代表实现部分。</p></li><li><p><strong>具体实现部分</strong>（<code>ConcreteImplementor</code>）：是实现部分的具体实现类。在 JavaScript 中，我们使用具体对象或构造函数来代表具体实现部分。</p></li><li><p><strong>客户端</strong>（<code>Client</code>）：是使用桥接模式的代码部分。在 JavaScript 中，我们可以在客户端中创建抽象部分和实现部分的对象，并进行组合和调用。</p></li></ul><p>以上是一个简单的桥接模式的用例图解析，通过使用桥接模式，我们可以将抽象部分和实现部分分离，使其可以独立地变化和扩展。</p><h2 id="二-实现桥接模式" tabindex="-1">二. 实现桥接模式 <a class="header-anchor" href="#二-实现桥接模式" aria-label="Permalink to &quot;二. 实现桥接模式&quot;">​</a></h2><h3 id="步骤-1-定义抽象类-或接口" tabindex="-1">步骤 1：定义抽象类（或接口） <a class="header-anchor" href="#步骤-1-定义抽象类-或接口" aria-label="Permalink to &quot;步骤 1：定义抽象类（或接口）&quot;">​</a></h3><p>首先，创建一个抽象类（或接口），它定义了抽象部分的接口和行为。这个抽象类可以是一个普通的 JavaScript 类，或者使用接口的方式。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义抽象类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AbstractClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">implementation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.implementation </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> implementation</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  performAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 委托实现类的具体方法</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.implementation.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="步骤-2-定义实现类" tabindex="-1">步骤 2：定义实现类 <a class="header-anchor" href="#步骤-2-定义实现类" aria-label="Permalink to &quot;步骤 2：定义实现类&quot;">​</a></h3><p>要实现桥接模式，需要创建一个或多个实现类，它们提供了抽象部分的具体实现。这些实现类可以是普通的 JavaScript 类。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义实现类A</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteImplementationA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ConcreteImplementationA is performing action&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义实现类B</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteImplementationB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  action</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ConcreteImplementationB is performing action&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="步骤-3-创建桥接实例" tabindex="-1">步骤 3：创建桥接实例 <a class="header-anchor" href="#步骤-3-创建桥接实例" aria-label="Permalink to &quot;步骤 3：创建桥接实例&quot;">​</a></h3><p>通过将实现类实例传递给抽象类的构造函数，创建一个桥接实例。这样，抽象类引用了具体的实现类。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建桥接实例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> instance1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AbstractClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteImplementationA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">instance1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">performAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出：ConcreteImplementationA is performing action</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> instance2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AbstractClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteImplementationB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">instance2.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">performAction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出：ConcreteImplementationB is performing action</span></span></code></pre></div><p>在上面的代码中，我们进行了 3 个步骤，完整的实现了一个桥接模式的运用。</p><p>首先，我们定义了一个抽象类 <code>AbstractClass</code>，它接收一个具体的实现类实例作为参数，并在 <code>performAction</code> 方法中调用实现类的 <code>action</code> 方法。</p><p>然后，我们定义了两个具体的实现类 <code>ConcreteImplementationA</code> 和 <code>ConcreteImplementationB</code>，它们都实现了 <code>action</code> 方法，并有不同的实现。</p><p>最后，我们创建了两个桥接实例 <code>instance1</code> 和 <code>instance2</code>。当调用 <code>performAction</code> 方法时，实际执行的是具体实现类中的 <code>action</code> 方法，输出了不同的结果。</p><p>通过这样的实现，我们使用桥接模式将抽象部分和实现部分进行了解耦，可以灵活地改变或扩展实现类的行为，而不会影响到其他部分的代码。</p><h2 id="三-桥接模式的优缺点" tabindex="-1">三. 桥接模式的优缺点 <a class="header-anchor" href="#三-桥接模式的优缺点" aria-label="Permalink to &quot;三. 桥接模式的优缺点&quot;">​</a></h2><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ol><li><p><strong>解耦性强</strong>：桥接模式能将抽象部分和实现部分相互解耦，使它们可以独立变化。通过将抽象类和实现类分离，可以使它们可以独立进行修改和扩展，不会相互影响。</p></li><li><p><strong>扩展性好</strong>：由于桥接模式能灵活地将抽象部分和实现部分组合起来，因此在需要新增实现类或抽象部分时，可以在不修改现有代码的情况下进行扩展。</p></li><li><p><strong>可复用性高</strong>：桥接模式中的抽象类可以通过不同的实现类进行组合，可以更好地复用已有的代码。实现类也可以在不同的抽类中进行复用。</p></li><li><p><strong>可以动态切换实现</strong>：桥接模式使得可以在运行时动态地切换具体的实现类，而不影响抽象类。这种动态切换可以在一定程度上实现运行时的灵活性和可定制性。</p></li></ol><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ol><li><p><strong>增加了系统的复杂性</strong>：使用桥接模式会增加一定的类和对象的数量，增加了系统的复杂性，会增加代码的阅读和维护难度。</p></li><li><p><strong>引入了间接性</strong>：桥接模式通过一层间接来把抽象部分和实现部分连接起来，有时候可能会导致理解和调试困难。</p></li></ol><p>综上所述，桥接模式在将抽象和实现部分相互解耦、提供灵活性和可扩展性方面具有明显的优势。但它也会增加系统的复杂性，并且引入了一层间接性。在具体应用时需要权衡利弊，根据实际需求决定是否使用桥接模式。</p><h2 id="四-应用案例" tabindex="-1">四. 应用案例 <a class="header-anchor" href="#四-应用案例" aria-label="Permalink to &quot;四. 应用案例&quot;">​</a></h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4237885318c246c7960ddaa636d0baf9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1148&amp;h=595&amp;s=36942&amp;e=png&amp;b=ffffff" alt="image.png"></p><p align="center">图形绘制应用</p><p>应用场景：假设有一个图形绘制应用，需要支持不同的图形形状（如矩形、圆形等）和不同的绘制颜色（如红色、蓝色等）的组合。这时可以使用桥接模式来实现。</p><p>首先，我们定义图形的抽象类 <code>Shape</code>：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Shape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.color </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> color</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  draw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Drawing a \${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">color</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">()</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">} \${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">constructor</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>然后，我们定义具体的图形类，如 <code>Rectangle</code> 和 <code>Circle</code>：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Rectangle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Shape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(color)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Circle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Shape</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(color)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>接下来，我们定义颜色的抽象类 <code>Color</code>：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;This method must be overridden&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>再然后，我们具体的颜色类，如 <code>Red</code> 和 <code>Blue</code>：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Red</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;red&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Blue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;blue&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>最后，我们可以通过桥接模式来创建图形，并指定具体的颜色：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> redRectangle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Rectangle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Red</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">redRectangle.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">draw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出：Drawing a red Rectangle</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> blueCircle</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Circle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Blue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">blueCircle.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">draw</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出：Drawing a blue Circle</span></span></code></pre></div><p>在上面的实例中，我们使用桥接模式将图形的抽象部分（<code>Shape</code>）和颜色的抽象部分（<code>Color</code>）分离开来，并通过组合的方式将它们连接起来。</p><p>通过定义具体的图形类（<code>Rectangle</code> 和 <code>Circle</code>）和具体的颜色类（<code>Red</code> 和 <code>Blue</code>），我们可以根据需要灵活地组合不同的图形和颜色，实现各种绘制组合。</p><p>调用图形的 <code>draw</code> 方法，实际上会调用具体的颜色类的 <code>fill</code> 方法，输出相应的绘制信息。</p><p>这样，使用桥接模式可以让我们轻松扩展和修改图形的形状和颜色，而不会相互影响。同时，也提高了代码的可复用性和可维护性。</p><h2 id="五-桥接模式的最佳实践" tabindex="-1">五. 桥接模式的最佳实践 <a class="header-anchor" href="#五-桥接模式的最佳实践" aria-label="Permalink to &quot;五. 桥接模式的最佳实践&quot;">​</a></h2><ol><li><p><strong>明确定义抽象部分和实现部分</strong>：在设计桥接模式时，首先需要明确抽象部分和实现部分的功能和职责。抽象部分通常是高层模块，定义了抽象方法和属性，而实现部分是低层模块，负责实现具体的功能。</p></li><li><p><strong>组合而非继承</strong>：桥接模式通常通过组合来连接抽象部分和实现部分，而不是使用继承。这样可以实现抽象部分和实现部分的解耦，同时也更加灵活地扩展和变化。</p></li><li><p><strong>通过接口或抽象类定义抽象部分</strong>：在 JavaScript 中，可以使用接口或抽象类来定义抽象部分的方法和属性。这可以为具体的实现类提供一个共同的接口，方便统一调用。</p></li><li><p><strong>应用适当的设计模式</strong>：桥接模式可以与其他设计模式配合使用，以实现更复杂的功能。例如，可以与工厂模式结合，用于创建不同的实现类实例。</p></li><li><p><strong>考虑灵活性和可扩展性</strong>：桥接模式的优势之一是灵活性和可扩展性。因此，在设计时应该考虑到后续可能的变化和扩展。如需新增抽象部分或实现部分，应该可以轻松添加新的类而不影响现有的代码。</p></li></ol><p>总之，JavaScript 桥接模式的最佳实践是明确定义抽象部分和实现部分、使用组合而不是继承、通过接口或抽象类定义抽象部分、应用适当的设计模式、考虑灵活性和可扩展性，以及合理命名和组织代码。这样能够使得代码结构清晰、可维护性高，并且能够轻松地扩展和修改功能。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>在本篇文章中，我们详细解析了 JavaScript 桥接模式的基础和应用，并总结了项目最佳实践。桥接模式通过将抽象部分和实现部分分离，可以让它们分别独立变化，以实现更灵活的扩展和变化。</p><p>当你需要设计具有多个不同维度的变化的系统时，桥接模式是一个很好的选择。它可以避免类的指数级增长，并且能够灵活组合不同的抽象和实现。</p><p>通过桥接模式，我们可以轻松地组合不同的抽象和实现，满足不同的需求。同时，桥接模式还提供了代码重用和可维护性的好处，使得我们的代码更加整洁和可扩展。</p>`,65);function k(r,d,c,o,E,g){const s=t("ArticleFooter");return l(),a("div",null,[e,n(s,{link:"https://juejin.cn/post/7293176193323237414"})])}const C=i(h,[["render",k]]);export{F as __pageData,C as default};
