import{_ as i,c as a,I as n,aU as p,o as l,E as h}from"./chunks/framework.CpXV_ol5.js";const F=JSON.parse('{"title":"JS设计模式之装饰者模式：优雅的给对象增添“魔法”","description":"","frontmatter":{"title":"JS设计模式之装饰者模式：优雅的给对象增添“魔法”"},"headers":[],"relativePath":"zh/blog/design-pattern/结构型-装饰者模式.md","filePath":"zh/blog/design-pattern/结构型-装饰者模式.md","lastUpdated":1727083629000}'),t={name:"zh/blog/design-pattern/结构型-装饰者模式.md"},k=p(`<h1 id="结构型-装饰者模式" tabindex="-1">结构型 - 装饰者模式 <a class="header-anchor" href="#结构型-装饰者模式" aria-label="Permalink to &quot;结构型 - 装饰者模式&quot;">​</a></h1><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/011e9d8ab8e3449aa93b02bca0543717~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1328&amp;h=666&amp;s=176238&amp;e=png&amp;b=128383" alt="image.png"></p><h2 id="引言" tabindex="-1">引言 <a class="header-anchor" href="#引言" aria-label="Permalink to &quot;引言&quot;">​</a></h2><p>在前端开发中，我们经常会遇到需要在不修改已有代码的基础上给对象添加新的行为或功能的情况。而传统的继承方式并不适合这种需求，因为继承会导致类的数量急剧增加，且每一个子类都会固定地实现一种特定的功能扩展。</p><p>装饰者模式则提供了一种更加灵活的解决方案。它可以在运行时动态地给对象新的功能，同时避免了继承带来的类爆炸问题。</p><p>本篇文章将会详细介绍 JavaScript 设计模式装饰者模式。通过阅读本文，你将了解到如使用装饰者模式来动态地扩展对象的功能，同时保持代码的灵活性和可维护性。</p><h2 id="一-什么是装饰者模式" tabindex="-1">一. 什么是装饰者模式 <a class="header-anchor" href="#一-什么是装饰者模式" aria-label="Permalink to &quot;一. 什么是装饰者模式&quot;">​</a></h2><h3 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h3><p>装饰者模式（<code>Decorator Pattern</code>）是一种结构型设计模式，它允许将对象包在其他对象中，而无需改变对象的原始结构，从而动态地为其添加新的行为和功能，并且不会改变原有对象的结构。</p><p>装饰者模式通过将对象包装到一个装饰器中，将新的行为包裹在原始对象周围，以增强其功能。这种模式通过使用组合而不是继承的方式，可以在运行时动态地添加、删除或修改对象的功能。</p><h3 id="核心思想" tabindex="-1">核心思想 <a class="header-anchor" href="#核心思想" aria-label="Permalink to &quot;核心思想&quot;">​</a></h3><p>装饰者模式的核心思想是通过组合来实现功能的扩展，而不是通过继承。通过将对象包装进装饰器对象中，可以在需要的时候像堆叠木块一样一层层地添加功能，也可以在不需要某个功能时轻松地移除它。</p><p>使用装饰者模式可以提供灵活性和可扩展性，同时也遵循开闭原则，即对修改关闭，对扩展开放。它可以帮助我们避免继承链的臃肿和复杂化，将对象的功能拆分为不同的装饰器，使得代码更加可维护和可复用。</p><h3 id="主要特点" tabindex="-1">主要特点 <a class="header-anchor" href="#主要特点" aria-label="Permalink to &quot;主要特点&quot;">​</a></h3><p>装饰者模式具有以下主要特点：</p><ol><li><p><strong>动态添加行为</strong>：装饰者模式允许在运行时动态地向对象添加新的行为，而不需要修改已有的代码或对象的结构。通过将对象包装在装饰器中，可以在不改变原始对象的情况下，增加、修改或删除对象的功能。</p></li><li><p><strong>组合而非继承</strong>：装饰者模式通过组合而不是继承的方式，实现了对对象的功能扩展。不同于继承链的方式，装饰者模式允许你根据需要灵活地组合多个装饰器，以实现不同的功能组合。</p></li><li><p><strong>透明性</strong>：装饰者模式使得装饰器和原始对象具有相同的接口，这意味着对于使用对象的客户端来说，无论是使用原始对象还是装饰器对象，都可以一致地进行操作，而不会产生任何混淆。</p></li><li><p><strong>可逆性</strong>：装饰者模式允许随时添加、删除或修改对象的行为，因此具有可逆性。即如果你不再需要某个装饰器的功能，可以很容易地将其从装饰器堆栈中移除，恢复到原始对象的状态。</p></li><li><p><strong>灵活性和可扩展性</strong>：通过装饰者模式，可以灵活地扩展对象的功能，而无需修改原始对象或其他装饰器。你可以根据需要组合不同的装饰器，构建出复杂的功能组合，同时保持代码的可维护性和可复用性。</p></li></ol><blockquote><p>总的来说，装饰者模式提供了一种灵活、可扩展和可逆的方式来动态地添加对象的行为。它使得功能扩展变得简单，同时通过组合而非继承的方式，避免了继承链的复杂性和僵化性。这使得代码更加灵活、可维护和可复用。</p></blockquote><h2 id="二-装饰者模式的结构" tabindex="-1">二. 装饰者模式的结构 <a class="header-anchor" href="#二-装饰者模式的结构" aria-label="Permalink to &quot;二. 装饰者模式的结构&quot;">​</a></h2><p>装饰者模式的结构主要包含以下几个角色：</p><ol><li><p><strong>组件</strong>（Component）：定义一个接口或抽象类，作为装饰器和具体组件对象的公共接口。它可以是一个类或者接口，它声明了具体组件和装饰器需要实现的方法。</p></li><li><p><strong>具体组件</strong>（ConcreteComponent）：实现了组件接口，也就是被装饰的对象。它是原始对象，具有基本的功能。</p></li><li><p><strong>装饰器</strong>（Decorator）：实现了组件接口，并持有一个被装饰的组件对象的引用。装饰器通过对被装饰对象的包装，可以在不修改原始对象的基础上，动态地添加额外的行为。它具有与组件相同的接口，可以递归地包装其他装饰器或具体组件。</p></li><li><p><strong>具体装饰器</strong>（ConcreteDecorator）：扩展了装饰器类，实现了具体的装饰逻辑。具体装饰器可以在调用被装饰对象的方法之前或之后，添加额外的行为。</p></li></ol><p>下面是 JavaScript 装饰者模式的结构示意图：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21fab0141a0d4f29b673fc0184e272d1~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1896&amp;h=1172&amp;s=86622&amp;e=png&amp;b=ffffff" alt="image.png"></p><p>在这个结构中，<strong>具体组件</strong>（ConcreteComponent）是被装饰的原始对象，它实现了组件接口，并具有基本的功能。<strong>装饰器</strong>（Decorator）也实现了组件接口，并持有一个被装饰的组件对象的引用。<strong>具体装饰器</strong>（ConcreteDecorator）扩展了装饰器类，可以在调用被装饰对象的方法之前或之后，添加额外的行为。</p><p>通过组件接口的统一，装饰器和具体组件对象可以互相替换，使得客户端可以透明地使用装饰后的对象。可以根据需求灵活地组合装饰器，实现不同的功能组合。</p><blockquote><p>注意：装饰者模式中的装饰器和具体组件对象之间是松耦合的关系，它们之间通过共同的接口进行交互，不依赖具体的实现，从而实现了动态扩展和变更功能的目的。</p></blockquote><h2 id="三-如何实现装饰者模式" tabindex="-1">三. 如何实现装饰者模式 <a class="header-anchor" href="#三-如何实现装饰者模式" aria-label="Permalink to &quot;三. 如何实现装饰者模式&quot;">​</a></h2><p>装饰者模式的实现步骤可以分为以下几个步骤：</p><ol><li><strong>定义组件接口或抽象类</strong>：</li></ol><p>定义一个基础的组件接口或抽象类，它是被装饰者和装饰器共同实现的接口。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 组件接口或抽象类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="2"><li><strong>实现具体组件类</strong>：</li></ol><p>创建一个实现了组件接口或抽象类的具体组件类，也就是被装饰者。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 具体组件类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;执行具体组件的操作&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="3"><li><strong>定义装饰器抽象类</strong>：</li></ol><p>创建一个装饰器抽象类，继承自组件接口或抽象类，它将持有一个被装饰的组件对象。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 装饰器抽象类</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Decorator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.component </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> component</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.component.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="4"><li><strong>实现具体装饰器类</strong>：</li></ol><p>创建具体的装饰器类，继承自装饰器抽象类，可以在不修改原有对象的情况下，为它添加额外的行为。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 具体装饰器类A</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteDecoratorA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Decorator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addBehaviorA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  addBehaviorA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;添加额外的行为A&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 具体装饰器类B</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteDecoratorB</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Decorator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addBehaviorB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  addBehaviorB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;添加额外的行为B&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="5"><li><strong>创建装饰链</strong>：</li></ol><p>可以按需创建装饰链，将具体的装饰器对象以特定的顺序组合在一起。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建被装饰的具体组件对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> component</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建具体装饰器对象A，并传入component</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> decoratorA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteDecoratorA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(component)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建具体装饰器对象B，并传入decoratorA</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> decoratorB</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ConcreteDecoratorB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(decoratorA)</span></span></code></pre></div><ol start="6"><li><strong>调用装饰后的对象方法</strong>：</li></ol><p>通过装饰后的对象来调用方法，观察装饰器是否成功地添加了额外的行为。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 调用装饰后的对象的方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">decoratorB.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>在上述步骤中，我们首先定义了一个抽象类 <code>Component</code> 作为组件的基本接口。然后创建了具体组件类 <code>ConcreteComponent</code>，实现了组件接口的 <code>operation</code> 方法。</p><p>接下来，我们定义了一个装饰器抽象类 <code>Decorator</code>，其构造函数接收一个组件对象，通过调用组件对象的 <code>operation</code> 方法来实现组件的操作。</p><p>然后，我们创建了两个具体装饰器类 <code>ConcreteDecoratorA</code> 和 <code>ConcreteDecoratorB</code>，它们继承自装饰器抽象类，并实现了自己的增加行为的方法。</p><p>最后，我们创建了被装饰的具体组件对象 <code>component</code>，然后按照一定顺序创建了具体装饰器对象 <code>decoratorA</code> 和 <code>decoratorB</code>，并将它们串联起来形成装饰链。最后，调用装饰后的对象 <code>decoratorB</code> 的 <code>operation</code> 方法，观察它的输出。</p><p>这样，通过装饰器模式，我们可以在不改变原有对象的情况下，动态地扩展对象的功能。</p><h2 id="四-装饰者模式的应用场景" tabindex="-1">四. 装饰者模式的应用场景 <a class="header-anchor" href="#四-装饰者模式的应用场景" aria-label="Permalink to &quot;四. 装饰者模式的应用场景&quot;">​</a></h2><p>在 JavaScript 中，装饰者模式可以应用于各种场景，用于动态地给对象添加额外的功能或行为。以下是一个详细的代码分析，展示了 JavaScript 装饰者模式是如何应用的。</p><p>假设我们有一个简单的组件，用于展示用户的个人信息，包括姓名、年龄和职业。我们希望能够根据用户的权限动态地添加一些额外功能，比如显示用户的手机号码或地址，同时保持代码的灵活性。</p><ol><li>首先，我们创建一个基础的用户信息组件 <code>UserInfo</code>：</li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">occupation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.occupation </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> occupation</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Name: \${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Age: \${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">age</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Occupation: \${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">occupation</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="2"><li>然后，我们创建一个装饰者类 <code>PhoneDecorator</code>，用于在用户信息中添加显示手机号码的功能：</li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PhoneDecorator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">userInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">phoneNumber</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.userInfo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> userInfo</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.phoneNumber </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> phoneNumber</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.userInfo.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Phone: \${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">phoneNumber</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="3"><li>接下来，我们创建另一个装饰者类 <code>AddressDecorator</code>，用于在用户信息中添加显示地址的功能：</li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AddressDecorator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">userInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">address</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.userInfo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> userInfo</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.address </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> address</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.userInfo.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Address: \${</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">address</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="4"><li>现在，我们可以使用这些装饰者来动态地添加功能。下面是应用装饰者模式的示例代码：</li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建基础的用户信息对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> userInfo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserInfo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;John Doe&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Engineer&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建装饰者对象并应用装饰器</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> phoneDecorator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> PhoneDecorator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(userInfo, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;1234567890&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> addressDecorator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AddressDecorator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(phoneDecorator, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;123 Main St&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 渲染用户信息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">addressDecorator.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>输出结果将会是：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Name: John Doe</span></span>
<span class="line"><span>Age: 30</span></span>
<span class="line"><span>Occupation: Engineer</span></span>
<span class="line"><span>Phone: 1234567890</span></span>
<span class="line"><span>Address: 123 Main St</span></span></code></pre></div><p>通过使用装饰者模式，我们可以动态地为用户信息对象添加不同的功能组合，而不需要修改原始对象，从而实现了代码的灵活性和扩展性。</p><blockquote><p>注意：以上代码只是一个简化的示例，实际应用中可能会更加复杂。装饰者模式的实现也可以有很多变体，具体的实现方式可以根据需求和设计的复杂度来决定。</p></blockquote><h2 id="五-装饰者模式的优缺点" tabindex="-1">五. 装饰者模式的优缺点 <a class="header-anchor" href="#五-装饰者模式的优缺点" aria-label="Permalink to &quot;五. 装饰者模式的优缺点&quot;">​</a></h2><h3 id="装饰者模式的优点" tabindex="-1">装饰者模式的优点 <a class="header-anchor" href="#装饰者模式的优点" aria-label="Permalink to &quot;装饰者模式的优点&quot;">​</a></h3><ol><li><p><strong>动态扩展</strong>：装饰者模式允许在运行时动态为对象添加新的功能或行为，而无需修改原始对象的结构。这使得代码更加灵活，能够根据需求动态地组合和应用装饰器。</p></li><li><p><strong>开闭原则</strong>：装饰者模式符合开闭原则，可以在不修改已有代码的情况下扩展新的功能。通过添加新的装饰器，可以在不改变原始对象的代码的前提下，扩展和修改对象的行为。</p></li><li><p><strong>单一职责原则</strong>：装饰者模式将具体功能的实现分散到不同的装饰器类中，每个装饰器只关注自己的功能实现，使得代码结构清晰，符合单一职责原则。</p></li><li><p><strong>组合灵活</strong>：通过灵活组合不同的装饰器，可以实现多种功能组合，满足不同的需求。装饰器模式提供了一种仅通过不同的组合方式就可以实现复杂功能的便捷方法。</p></li></ol><h3 id="装饰者模式的缺点" tabindex="-1">装饰者模式的缺点 <a class="header-anchor" href="#装饰者模式的缺点" aria-label="Permalink to &quot;装饰者模式的缺点&quot;">​</a></h3><ol><li><p><strong>复杂性增加</strong>：装饰者模式引入了大量的类和对象，使得代码结构变得复杂。在设计和理解装饰器链的同时，需要考虑装饰器之间的关系和顺序。</p></li><li><p><strong>运行时性能开销</strong>：由于装饰者模式是通过多层嵌套的方式来添加功能的，每个装饰器都会增加一次方法调用的开销。这可能在性能敏感的场景中产生一定的性能损失。</p></li><li><p><strong>额外对象的创建</strong>：每个装饰器需要持有一个被装饰的对象，这样会增加多个对象的创建和维护成本。在需要大量对象时，可能会占用较多的内存空间。</p></li></ol><blockquote><p>综上所述，装饰者模式提供了动态扩展和灵活组合功能的方式，符合开闭原则和单一职责原则，但也可能导致代码复杂性增加和运行时性能开销。在使用时需要根据实际情况进行权衡和选择。</p></blockquote><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>在本篇文章中，我们详细解析了 JavaScript 中的装饰者模式及其应用。装饰者模式是一种结构型设计模式，通过动态地给对象添加新的行为，实现了功能的扩展和组合，同时遵循开闭原则和单一职责原则。</p><p>在使用装饰者模式时，我们需要注意合理地设计装饰者类的层级结构，避免过多的装饰者嵌套导致代码复杂度的增加。同时，要确保每个装饰者类的职责单一，只关注一个特定的功能扩展。</p><p>装饰者模式在实际开发中有着广泛的应用，如日志记录、性能监测、权限验证等。它不仅提供了一种灵活的扩展方式，还能帮助我们解耦和复用代码。</p><p>通过学习和理解装饰者模式，我们能够更加灵活地设计和开发 JavaScript 应用，提高代码的可扩展性和维护性。</p>`,76);function e(r,E,o,d,g,c){const s=h("ArticleFooter");return l(),a("div",null,[k,n(s,{link:"https://juejin.cn/post/7283776161527070757"})])}const C=i(t,[["render",e]]);export{F as __pageData,C as default};
