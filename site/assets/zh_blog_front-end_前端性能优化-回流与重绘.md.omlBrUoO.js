import{_ as e,c as t,I as i,aU as a,o as p,E as l}from"./chunks/framework.CpXV_ol5.js";const u=JSON.parse('{"title":"前端性能优化 ｜ 回流与重绘","description":"","frontmatter":{"title":"前端性能优化 ｜ 回流与重绘"},"headers":[],"relativePath":"zh/blog/front-end/前端性能优化-回流与重绘.md","filePath":"zh/blog/front-end/前端性能优化-回流与重绘.md","lastUpdated":1727083629000}'),r={name:"zh/blog/front-end/前端性能优化-回流与重绘.md"},n=a('<h1 id="前端性能优化-回流与重绘" tabindex="-1">前端性能优化 ｜ 回流与重绘 <a class="header-anchor" href="#前端性能优化-回流与重绘" aria-label="Permalink to &quot;前端性能优化 ｜ 回流与重绘&quot;">​</a></h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac7bbf7034584301bcb33a66b00ea493~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=751&amp;h=309&amp;s=49212&amp;e=png&amp;b=f4f3dd" alt="image.png"></p><h2 id="一、回流与重绘的概念" tabindex="-1">一、回流与重绘的概念 <a class="header-anchor" href="#一、回流与重绘的概念" aria-label="Permalink to &quot;一、回流与重绘的概念&quot;">​</a></h2><p>在 HTML 中，每个元素都可以理解成一个盒子，在浏览器解析过程中，会涉及到回流与重绘：</p><ul><li><p>回流（reflow）：当 DOM 的结构发生改变或者某个元素的样式发生变化时，浏览器需要重新计算并重新布局（layout）页面中的元素，这个过程就称为回流。回流会导致浏览器重新计算元素的位置和大小，然后重新绘制到屏幕上，是一种相对耗费资源的操作。</p></li><li><p>重绘（repaint）：当页面元素的样式（如颜色、背景等）发生变，但并不影响其布局时，浏览器只需要重新绘制（repaint）这些元素，而无需重新计算元素的布局，这个过程称为重绘。重绘的性能开销较小，因只是简单地更新元素的样式。</p></li></ul><blockquote><p>回流和重绘都会带来性能消耗，因此在前端开发中，要尽可能减少回流和重绘的次数，以提高页面的渲染性能。</p></blockquote><p>要了解回流与重绘的产生，首先需要了解浏览器解析渲染机制，如下所示：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3bc2edb0ff2f4d6cb00b636ab7c9c1b4~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><p>浏览器的解析渲染机制可以分为以下几个步骤：</p><ol><li><p><strong>HTML 解析</strong>：当浏览器接收到 HTML 文档后，会对其进行解析。解析器会将 HTML 文档按照标签的层次结构转换成一个 DOM 树（文档对象模型）。 DOM 树表示了文档的结构，每个 HTML 标签都对应着 DOM 树中的一个节点。</p></li><li><p><strong>CSS 解析</strong>：浏览器会解析 CSS 样式表，构建 CSSOM （CSS 对象模型）。 CSSOM 表示了文档的样式信息，每个 CSS 样式规则都对应着 CSSOM 中的一个对象。</p></li><li><p><strong>渲染树构建</strong>：将 DOM 树和 CSSOM 合并构建渲染树（<code>Render Tree</code>）。渲染树只包含需要显示的元素，隐藏的元素不会包含在渲染树中。渲染树不包含 CSS 中的一些影响布局但不显示的元素，比如：<code>display:none</code>的元素。</p></li><li><p><strong>布局（Layout）</strong>：布局阶段确定渲染树中每个节点的精确位置和大小，按照文档流模型进行布局。计算节点的几何属性，比如位置、大小等。</p></li><li><p><strong>绘制（Paint）</strong>：根据渲染树的布局信息，将每个节点转换为屏幕上的实际像素，通过绘制进行渲染。</p></li><li><p><strong>栅格化（Rasterization）</strong>：将绘制得到的图像划分成图块，然后将每个图块转化成屏幕上的像素。</p></li><li><p><strong>合成（Composition）</strong>：将图块按照正确的顺序合并，形成最终的页面图像。</p></li></ol><p>以上步骤并非严格的顺序执行，其中一些步骤可能会并行进行，以提高效率。在渲染过程中，如果发生了样式改变，浏览器会重新执行布局和绘制操作，更新渲染结果。</p><p>所以在页面初始渲染阶段，回流不可避免的触发，可以理解成页面一开始是空白的元素，后面添加了新的元素使页面布局发生改变</p><p>当我们对  DOM  的修改引发了  DOM  几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来</p><p>当我们对  DOM  的修改导致了样式的变化（<code>color</code>或<code>background-color</code>），却并未影响其几何属性时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式，这里仅仅触发了重绘。</p><h2 id="二、回流与重绘的触发条件" tabindex="-1">二、回流与重绘的触发条件 <a class="header-anchor" href="#二、回流与重绘的触发条件" aria-label="Permalink to &quot;二、回流与重绘的触发条件&quot;">​</a></h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84386fbbaf8a49459cebf3fd5b74bfb1~tplv-k3u1fbpfcp-watermark.image?" alt="image.png"></p><h3 id="回流的触发条件" tabindex="-1">回流的触发条件 <a class="header-anchor" href="#回流的触发条件" aria-label="Permalink to &quot;回流的触发条件&quot;">​</a></h3><p><strong>触发条件</strong>：当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化</p><p>以下这些操作会导致回流</p><ol><li><p><strong>添加或删除 DOM 元素</strong>：当添加、删除、修改 DOM 元素时，会导致整个或部分页面的布局发生变化，从而触发回流。</p></li><li><p><strong>修改元素的位置</strong>、尺寸或层级关系：修改元素的位置、尺寸或层级关系（如改变元素的宽度、高度、margin、padding、top、left、z-index 等）会导致元素重新布局，从而触发回流。</p></li><li><p><strong>文字内容的变化</strong>：当文字内容的变化导致元素尺寸发生变化时，会触发回流。例如，动态改变一个段落的文字内容，会导致段落元素重新计算并布局。</p></li><li><p><strong>浏览器窗口的变化</strong>：当浏览器窗口的大小变化时，需要重新计算并布局页面中的元素，从而触发回流。</p></li><li><p><strong>获取某些元素的样式或者布局信息</strong>：例如通过 JavaScript 获取元素的<code>offsetWidth</code>、<code>offsetHeight</code>、<code>offsetTop</code>、<code>offsetLeft</code>、<code>scrollTop</code>、<code>scrollLeft</code>等属性，这些操作会导致浏览器强制进行回流。</p></li></ol><p>在触发回流的时候，由于浏览器染页面是基于流式布局的，所以当触发回流时，会导致周围的 DOM 元素重新排列，它的影响范围有两种:</p><ul><li>全局范围: 从根节点开始，对整个渲染树进行重新布局</li><li>局部范围: 对渲染树的某部分或者一个渲染对象进行重新布局</li></ul><h3 id="重绘的触发条件" tabindex="-1">重绘的触发条件 <a class="header-anchor" href="#重绘的触发条件" aria-label="Permalink to &quot;重绘的触发条件&quot;">​</a></h3><p><strong>触发条件</strong>：当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置</p><p>以下这些操作会导致重绘</p><ol><li><p><strong>修改元素的颜色、背景色、边框颜色等样式属性</strong>：例如，将一个元素的背景色由红色改为蓝色，这样只会引发元素的重绘，而不会触发布局的改变。</p></li><li><p><strong>修改元素的透明度</strong>：当修改元素的透明度（<code>opacity</code>）时，会引发元素的重绘。</p></li><li><p><strong>改元素的文本样式</strong>：例如，修改元素的字体、字号、字重等文本样式属性，会触发元素的重绘。</p></li><li><p><strong>添加或修改元素的阴影效果</strong>：当元素的阴影效果发生变化时，会引发元素的重绘。</p></li><li><p><strong>修改元素的 visibility 属性</strong>：当修改元素的<code>visibility</code>属性为<code>hidden</code>或<code>visible</code>时，会引发元素的重绘。</p></li></ol><blockquote><p>注意：当触发回流时，一定会触发重绘，但是重绘不一定会引发回流</p></blockquote><h2 id="三、如何减少回流与重绘" tabindex="-1">三、如何减少回流与重绘 <a class="header-anchor" href="#三、如何减少回流与重绘" aria-label="Permalink to &quot;三、如何减少回流与重绘&quot;">​</a></h2><h3 id="浏览器优化机制" tabindex="-1">浏览器优化机制 <a class="header-anchor" href="#浏览器优化机制" aria-label="Permalink to &quot;浏览器优化机制&quot;">​</a></h3><p>浏览器针对回流和重绘，本身也具备一定的优化机制，但是仅是最基础的。</p><ol><li><p>批量处理：浏览器会将多次的回流和重绘操作合并为一次，减少性能开销。</p></li><li><p>延迟回流：对于多次数量的 DOM 操作，浏览器会将它们缓存在一起，然后一次性进行回流处理，这样可以减少回流的次数。</p></li></ol><h3 id="减少回流与重绘的措施" tabindex="-1">减少回流与重绘的措施 <a class="header-anchor" href="#减少回流与重绘的措施" aria-label="Permalink to &quot;减少回流与重绘的措施&quot;">​</a></h3><p>了解了回流与重绘的触发条件，我们可以尽量避免不该有的操作，减少回流与重绘，提高浏览器渲染性能</p><ol><li><p><strong>使用 CSS 动画代替 JavaScript 动画</strong>：CSS 动画是利用浏览器的硬件加速，性能更高效。尽量使用<code>transform</code>和<code>opacity</code>属性进行动画效果，避免使用会触发回流的属性，如<code>width</code>和<code>height</code>。</p></li><li><p><strong>批量修改样式</strong>：尽量避免频繁地修改元素的样式，可以将多个样式的修改集中到一次操作中，例如使用 CSS 的 class 进行批量修改。</p></li><li><p><strong>使用文档碎片（Document Fragment）</strong>：当需要频繁地操作 DOM 时，可以使用文档碎片来进行缓存，然后再一次性地将文档碎片添加到 DOM 树中，减少回流次数。</p></li><li><p><strong>避免强制同步布局</strong>：在读取布局相关的属性（如<code>offsetTop</code>、<code>offsetLeft</code>、<code>clientWidth</code>等）之前，先将其缓存起来，避免多次读取导致浏览器强制进行同步布局。</p></li><li><p><strong>使用 transform 和 position 属性</strong>：尽量使用<code>transform</code>属性进行元素的平移、旋转、缩放等操作，使用<code>position</code>属性进行定位，避免引起回流的属性，如<code>top</code>、<code>left</code>、<code>width</code>、<code>height</code>等。</p></li><li><p><strong>避免频繁改变窗口大小</strong>：改变窗口大小会触发回流，所以尽量避免频繁改变窗口大小。</p></li><li><p><strong>使用节流和防抖技术</strong>：对于一些频繁触发的事件（如<code>scroll</code>、<code>resize</code>），可以使用节流和防抖技术来控制事件的触发频率，减少回流和重绘。</p></li><li><p><strong>使用 translateZ 触发 GPU 加速</strong>：对于需要频繁变动的元素，例如动画元素，可以使用<code>translateZ(0)</code>触发 GPU 加速，减少回流和重绘。</p></li></ol><h2 id="结语" tabindex="-1">结语 <a class="header-anchor" href="#结语" aria-label="Permalink to &quot;结语&quot;">​</a></h2><p>在本篇文章中，我们详细探索了浏览器的回流和重绘，以及如何减少它们对页面性能的影响。回流和重绘是由于对页面进行布局和渲染的过程中，浏览器需要重新计算元素的几何信息和重新绘制元素造成的。</p><p>我们学习到了回流和重绘的定义和区别，以及触发回流和重绘的常见操作。同时，我们提供了一些减少回流和重绘的优化措施，如使用<code>transform</code>属性进行动画、使用<code>position</code>属性进行定位、缓存布局信息等。</p><p>通过采取这些措施，我们可以减少页面的回流次数，提高页面性能和用户体验。</p><p>总之，了解回流和重绘的原理，并且采取相应的优化措施，对于开发优化性能的网页和应用程序至关重要。希望通过本篇文章的内容，能够帮助大家更好地理解和应用这些知识，从而创建出更高效、流畅的用户界面。</p>',39);function c(s,d,g,h,f,b){const o=l("ArticleFooter");return p(),t("div",null,[n,i(o,{link:["juejin::https://juejin.cn/post/7270864903015514146","weixin::https://mp.weixin.qq.com/s/BfC4jY1ll6sk6fFZvLz-rg"]},null,8,["link"])])}const _=e(r,[["render",c]]);export{u as __pageData,_ as default};
