import{_ as i,c as a,I as t,aU as n,o as p,E as h}from"./chunks/framework.BTzRA3v_.js";const F=JSON.parse('{"title":"JS设计模式之策略模式：灵活、可扩展的编程利器","description":"","frontmatter":{"title":"JS设计模式之策略模式：灵活、可扩展的编程利器"},"headers":[],"relativePath":"zh/blog/design-pattern/行为型-策略模式.md","filePath":"zh/blog/design-pattern/行为型-策略模式.md","lastUpdated":1727083629000}'),l={name:"zh/blog/design-pattern/行为型-策略模式.md"},e=n(`<h1 id="行为型-策略模式" tabindex="-1">行为型 - 策略模式 <a class="header-anchor" href="#行为型-策略模式" aria-label="Permalink to &quot;行为型 - 策略模式&quot;">​</a></h1><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/550d4f0af1f749e38b13f139d97a5ca5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=668&amp;h=334&amp;s=103249&amp;e=png&amp;b=228383" alt="image.png"></p><h2 id="一-前言" tabindex="-1">一. 前言 <a class="header-anchor" href="#一-前言" aria-label="Permalink to &quot;一. 前言&quot;">​</a></h2><p>在 JavaScript 前端开发中，随着代码规模的增长和项目的复杂性，我们常常需要处理各种不同的条件和情况，而这可能导致代码变得冗长、难以维护。这时，我们就需要一种强大而灵活的编程模式来应对这些复杂的逻辑，策略模式就是其中之一。</p><p>策略模式是一种经典的设计模式，它通过将特定操作封装在独立的策略函数中，使得我们能够轻松地切换和组合不同的算法和策略。在 JavaScript 中，策略模式可以帮助我们处理各种条件判断、算法选择和逻辑分支，提高代码的可读性、可维护性和可扩展性。</p><p>在本篇文章中，我们将详细学习 JavaScript 策略模式的工作原理和实现步骤，从基本概念开始，帮助我们理解什么是策略模式以及它的核心思想。</p><p>通过掌握策略模式，相信大家都将能够编写更加灵活、可扩展的代码，提高你的开发效率和代码质量。</p><h2 id="二-什么是策略模式" tabindex="-1">二. 什么是策略模式 <a class="header-anchor" href="#二-什么是策略模式" aria-label="Permalink to &quot;二. 什么是策略模式&quot;">​</a></h2><p>JavaScript 策略模式（<code>Strategy Pattern</code>）是一种<strong>行为型设计模式</strong>，它可以帮助我们更好地组织和处理复杂的业务逻辑。通过将不同的算法或逻辑封装成独立的策略对象，使得这些策略对象可以在运行时根据需要进行切换或替换，从而实现灵活性和可扩展性。</p><h3 id="_1-基础概念" tabindex="-1">1. 基础概念 <a class="header-anchor" href="#_1-基础概念" aria-label="Permalink to &quot;1. 基础概念&quot;">​</a></h3><ul><li><p><strong>策略对象</strong>（<code>Strategy Object</code>）：策略对象封装了一个独立的算法或逻辑，通过接口或方法提供对外的调用接口。</p></li><li><p><strong>环境对象</strong>（<code>Context Object</code>）：环境对象拥有策略对象，并根据具体的需求选择合适的策略对象进行调用。环境对象提供了一致的接口，使得策略对象可以被灵活切换。</p></li></ul><h3 id="_2-核心思想" tabindex="-1">2. 核心思想 <a class="header-anchor" href="#_2-核心思想" aria-label="Permalink to &quot;2. 核心思想&quot;">​</a></h3><ul><li><p><strong>封装变化</strong>：策略模式的核心思想是封装不同的算法或逻辑，使得它们可以独立变化，而不影响其他部分的代码。这种封装可以提高代码的可维护性和可复用性。</p></li><li><p><strong>解耦调用</strong>：通过环境对象对策略对象进行调用，将调用与具体的策略对象解耦，使得调用者不需要知道策略对象的具体实现细节，只需要通过统一的接口进行调用。</p></li></ul><h3 id="_3-作用" tabindex="-1">3. 作用 <a class="header-anchor" href="#_3-作用" aria-label="Permalink to &quot;3. 作用&quot;">​</a></h3><ul><li><p><strong>简化复杂逻辑</strong>：策略模式可以将复杂的业务逻辑分解为多个简单的策略对象，每个对象专注于解决一个小问题，从而降低程序的复杂性。</p></li><li><p><strong>灵活扩展</strong>：由于策略对象可以独立变化，因此可以很方便地新增、替换或重构策略对象，而不会影响到其他部分的代码。这种灵活性可以帮助我们应对需求变化或新功能的加入。</p></li><li><p><strong>提高代码可复用性</strong>：将不同的算法或逻辑封装成策略对象后，可以在多个地方复用这些策略对象，避免了重复编写相似的代码。</p></li></ul><p>通过理解 JavaScript 策略模式的基础概念、核心思想和作用，我们可以更好地应用这一设计模式来组织和处理复杂的业务逻辑，提高代码的可维护性和可扩展性。</p><h3 id="_4-uml-类图" tabindex="-1">4. UML 类图 <a class="header-anchor" href="#_4-uml-类图" aria-label="Permalink to &quot;4. UML 类图&quot;">​</a></h3><p>以下是一个简化的策略模式的 UML 类图示例：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2725620e23eb4e6d9f930253d7358666~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1002&amp;h=375&amp;s=32233&amp;e=png&amp;b=ffffff" alt="image.png"></p><p>在上述类图中，有三个关键角色：</p><ol><li><p><code>Context</code>：上下文对象，它包含一个私有属性<code>strategy</code>，用于保存当前的策略对象。<code>Context</code>类中还包含了两个公共方法，<code>setStrategy()</code>方法用于设置策略对象，<code>executeStrategy()</code>方法用于执行策略算法。</p></li><li><p><code>Strategy</code>：策略接口或者基类，它定义了一个抽象的算法方法<code>algorithm()</code>，具体的策略类需要实现这个方法来提供具体的算法实现。</p></li><li><p><code>ConcreteStrategyA</code>和<code>ConcreteStrategyB</code>：具体的策略类，它们继承或实现<code>Strategy</code>接口，分别实现了<code>algorithm()</code>方法来提供具体的算法实现。</p></li></ol><p>在策略模式中，客户端代码通过<code>Context</code>对象与具体的策略对象进行交互，可以通过<code>setStrategy()</code>方法来设置所需的策略对象，然后通过<code>executeStrategy()</code>方法来执行策略算法。</p><h2 id="三-实现方式" tabindex="-1">三. 实现方式 <a class="header-anchor" href="#三-实现方式" aria-label="Permalink to &quot;三. 实现方式&quot;">​</a></h2><p>JavaScript 中实现策略模式的一般步骤如下：</p><h3 id="_1-定义策略函数" tabindex="-1">1. 定义策略函数 <a class="header-anchor" href="#_1-定义策略函数" aria-label="Permalink to &quot;1. 定义策略函数&quot;">​</a></h3><p>确定你需要实现的不同策略，并将每个策略封装在一个函数中。每个策略函数应该有相同的参数列表，并返回相同类型的结果。策略函数的数量取决于你的需求，可以是两个、三个或更多。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Step 1: 定义策略函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> strategyA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> strategyB</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arg </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arg</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_2-创建使用策略的上下文对象" tabindex="-1">2. 创建使用策略的上下文对象 <a class="header-anchor" href="#_2-创建使用策略的上下文对象" aria-label="Permalink to &quot;2. 创建使用策略的上下文对象&quot;">​</a></h3><p>这个对象可以是一个类的实例或一个简单的对象，它将作为策略模式的使用者。该对象应该有一个方法或属性来选择使用哪个策略函数。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Step 2: 创建上下文对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  strategy: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用于存储所选的策略函数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setStrategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">strategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.strategy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strategy</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  executeStrategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">arg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">strategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(arg)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_3-实现选择策略的方法" tabindex="-1">3. 实现选择策略的方法 <a class="header-anchor" href="#_3-实现选择策略的方法" aria-label="Permalink to &quot;3. 实现选择策略的方法&quot;">​</a></h3><p>在上下文对象中，定义一个方法或属性来选择特定的策略函数。这个方法或属性可以基于某些条件、用户输入或其他因素来决定选择哪个策略。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Step 3: 实现选择策略的方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setStrategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(strategyA) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 选择策略A</span></span></code></pre></div><h3 id="_4-调用所选的策略函数" tabindex="-1">4. 调用所选的策略函数 <a class="header-anchor" href="#_4-调用所选的策略函数" aria-label="Permalink to &quot;4. 调用所选的策略函数&quot;">​</a></h3><p>在上下文对象的方法中，调用所选的策略函数，并传递必要的参数。接收策略函数的返回值，并用于需要的地方。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Step 4: 调用所选的策略函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> resultA</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">executeStrategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(resultA) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: 6</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setStrategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(strategyB) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 选择策略B</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> resultB</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> context.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">executeStrategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(resultB) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: 9</span></span></code></pre></div><p>在上述示例中，首先定义了两个策略函数 <code>strategyA</code> 和 <code>strategyB</code>，它们分别执行不同的操作。然后创建了一个上下文对象 <code>context</code>，其中 <code>setStrategy</code> 方法用于选择策略函数，<code>executeStrategy</code> 方法用于调用所选的策略函数。通过调用 <code>setStrategy</code> 方法来选择不同的策略，在 <code>executeStrategy</code> 方法中调用所选的策略函数，并传递参数进行计算。</p><p>执行上述的代码，输出结果如下图所示：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f661705d3de46519ff2d48827b75480~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=800&amp;h=150&amp;s=17215&amp;e=png&amp;b=181818" alt="image.png"></p><p>总结而言，实现策略模式的步骤涉及定义策略函数、创建上下文对象、实现选择策略的方法以及调用所选策略函数。通过这些步骤，可以实现灵活的策略切换和重用，使代码更加模块化和可扩展。</p><h2 id="四-应用场景" tabindex="-1">四. 应用场景 <a class="header-anchor" href="#四-应用场景" aria-label="Permalink to &quot;四. 应用场景&quot;">​</a></h2><p>假设我们有一个购物车对象，里面包含了多个商品项，每个商品项有商品的名称和价格。我们可以定义一个计价策略对象，根据不同的计价规则进行计算。</p><p>在购物车计价的场景中，我们可以使用 JavaScript 策略模式来实现不同的计价策略。下面将以一个简单的示例来详细分析策略模式的应用。</p><p>首先，我们定义一个购物车对象和商品项的数据结构：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ShoppingCart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  addItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">price</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ name, price })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  calculateTotalPrice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">strategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strategy.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">calculate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.items)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> shoppingCart</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ShoppingCart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">shoppingCart.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;item1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">shoppingCart.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;item2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">shoppingCart.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;item3&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>在上述代码中，我们定义了一个 <code>ShoppingCart</code> 类，它包含一个 <code>items</code> 数组用于存储商品项。<code>addItem</code> 方法用于向购物车中添加商品项。<code>calculateTotalPrice</code> 方法用于计算总价，它接受一个策略对象作为参数。</p><p>接下来，我们定义计价策略对象和相应的计价规则：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RegularPriceStrategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  calculate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">items</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reduce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">total</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item.price, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DiscountPriceStrategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">discount</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.discount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> discount</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  calculate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">items</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> totalPrice</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> items.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">reduce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">total</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item.price, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> totalPrice </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.discount)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> regularStrategy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RegularPriceStrategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> discountStrategy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DiscountPriceStrategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>在上述代码中，我们定义了两个计价策略对象：<code>RegularPriceStrategy</code> 和 <code>DiscountPriceStrategy</code>。<code>RegularPriceStrategy</code> 表示普通计价规则，即不打折的计价方式，通过对商品项的价格求和来计算总价。<code>DiscountPriceStrategy</code> 表示折扣计价规则，通过商品项价格求和后乘以折扣来计算总价。</p><p>最后，我们可以使用策略模式来计算购物车的总价：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> totalPrice1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> shoppingCart.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">calculateTotalPrice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(regularStrategy)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(totalPrice1) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: 60</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> totalPrice2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> shoppingCart.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">calculateTotalPrice</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(discountStrategy)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(totalPrice2) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出: 54</span></span></code></pre></div><p>在上述代码中，我们分别使用 <code>calculateTotalPrice</code> 方法来计算购物车的总价，分别传入不同的计价策略对象。通过策略对象的 <code>calculate</code> 方法来计算总价。</p><p>运行上述的代码，最终输出的计算结果如下图所示：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93f54a74086f4779a70041057f9594a9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=803&amp;h=138&amp;s=17238&amp;e=png&amp;b=181818" alt="image.png"></p><p>通过以上的实现，我们可以灵活地切换购物车计价的规则，只需要定义新的计价策略对象即可。这符合开闭原则，使得代码更易维护和扩展。</p><p>综上所述，购物车计价场景是策略模式的一个典型应用。我们定义了不同的计价策略对象，每个策略对象封装了不同的计价规则。通过切换不同的策略对象，实现了不同的计价方式。这样可以使得代码结构更清晰、易于维护，并且可以方便地扩展其他的计价规则。</p><h2 id="五-优缺点" tabindex="-1">五. 优缺点 <a class="header-anchor" href="#五-优缺点" aria-label="Permalink to &quot;五. 优缺点&quot;">​</a></h2><p>通过以上对策略模式的了解和分析，我们可以总结一下 JavaScript 策略模式的优缺点：</p><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ol><li><p><strong>灵活性高</strong>：策略模式允许动态切换算法或策略，使得程序可以根据不同的需求使用不同的策略，提高了代码的灵活性。</p></li><li><p><strong>可扩展性好</strong>：添加新的策略只需要实现一个新的策略函数即可，不需要修改已有的代码，可以很方便地对代码进行扩展。</p></li></ol><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ol><li><p><strong>增加了代码复杂度</strong>：在使用策略模式时，需要编写多个策略函数，可能会增加代码的复杂度和文件体积。对于简单的场景，引入策略模式可能会显得过于复杂。</p></li><li><p><strong>需要额外管理策略对象</strong>：策略模式需要额外的对象来管理不同的策略函数，这可能增加一些额外的开销。</p></li></ol><p>策略模式能够提供灵活、可扩展、可维护和可测试的代码结构，使得代码具有更好的可复用性和可变性。但是在一些简单的场景中，可能会因为引入策略模式而增加代码的复杂性，需要根据具体情况进行权衡和选择。</p><h2 id="六-总结" tabindex="-1">六. 总结 <a class="header-anchor" href="#六-总结" aria-label="Permalink to &quot;六. 总结&quot;">​</a></h2><p>在 JavaScript 中，策略模式可以帮助我们处理不同算法、策略之间的切换和组合，为我们提供了一种强大的编程利器。</p><p>通过本篇文章的学习，我们了解了 JavaScript 策略模式的基本实现步骤。总结如下：</p><ul><li><p>首先，我们需要定义不同的策略函数，每个策略函数实现一个独立的算法或策略。</p></li><li><p>然后，创建一个上下文对象，这个对象作为策略模式的使用者，负责选择并执行特定的策略函数。在上下文对象中，我们还可以实现选择策略的方法，根据不同的条件或需求来动态选择策略函数。</p></li><li><p>最后，在上下文对象的方法中调用所选的策略函数，并处理返回的结果。</p></li></ul><p>上面我们也分析了策略模式的优缺点，优点在于它的灵活性和可扩展性。通过将不同的策略封装在独立的函数中，根据不同的需求来灵活选择和切换策略，而无需修改原有的代码。然而它也有一些缺点，比如增加了代码复杂度和额外的策略管理对象。在一些简单的场景中，引入策略模式可能会显得过度设计，增加不必要的开销。</p><p>因此，在使用策略模式时，我们需要权衡利弊，选择合适的模式来应对具体的需求和问题。</p><p>总结而言，JavaScript 策略模式是一种强大的编程工具，它是可以应用于多种场景的通用解决方案，无论是处理业务逻辑、算法优化还是用户交互，都能发挥着重要的作用。</p>`,70);function k(r,E,d,g,c,o){const s=h("ArticleFooter");return p(),a("div",null,[e,t(s,{link:"https://juejin.cn/post/7314519123177209868"})])}const u=i(l,[["render",k]]);export{F as __pageData,u as default};
